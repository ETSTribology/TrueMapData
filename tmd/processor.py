"""
TMD file processor module for reading and parsing height map data files.

This module provides the TMDProcessor class that handles reading
and parsing TMD (TrueMap Data) files from both TrueMap and GelSight devices.
"""

import os
import traceback
import logging
import numpy as np
from typing import Dict, Any, Optional, Tuple, List
from pathlib import Path

from tmd.utils.utils import process_tmd_file, hexdump

# Configure logger for this module
logger = logging.getLogger(__name__)


class TMDProcessor:
    """
    Process TMD files generated by TrueMap or GelSight devices.

    This class supports reading TMD files with different layouts and versions and provides
    methods for extracting metadata and height maps from the binary data. It handles both
    v1 and v2 TMD file formats and provides diagnostic capabilities.

    Attributes:
        file_path: Path to the TMD file
        basename: Filename of the TMD file (without path)
        data: Dictionary of extracted data after processing
        debug: Flag to enable verbose debugging output
    """

    def __init__(self, file_path: str) -> None:
        """
        Initialize the processor with a TMD file path.

        Args:
            file_path: Path to the TMD file to process
        """
        self.file_path: str = file_path
        self.basename: str = os.path.basename(file_path)
        self.data: Optional[Dict[str, Any]] = None
        self.debug: bool = False
        self._stats_cache: Dict[str, Any] = {}  # Cache for expensive operations

    def set_debug(self, debug: bool = True) -> "TMDProcessor":
        """
        Enable or disable debug mode for detailed output.

        Args:
            debug: True to enable debugging; False to disable

        Returns:
            Self instance for method chaining
        """
        self.debug = debug
        logger.setLevel(logging.DEBUG if debug else logging.INFO)
        return self

    def print_file_header(self, num_bytes: int = 64) -> None:
        """
        Print the first few bytes of the file in both hex and ASCII formats.

        Args:
            num_bytes: Number of bytes to read from the file header

        Raises:
            FileNotFoundError: If the file does not exist
        """
        if not os.path.exists(self.file_path):
            raise FileNotFoundError(f"File not found: {self.file_path}")

        with open(self.file_path, "rb") as f:
            header_bytes = f.read(num_bytes)

        # Generate a nice hex dump
        hex_dump = hexdump(header_bytes, width=16)
        ascii_repr = header_bytes.decode("ascii", errors="replace")

        logger.info("File header hex dump:\n%s", hex_dump)
        logger.info("File header ASCII: %s", ascii_repr)

    def get_stats(self) -> Dict[str, Any]:
        """
        Calculate statistics for the processed height map.

        Returns:
            Dictionary containing statistics (min, max, mean, std, etc.)

        Raises:
            ValueError: If the file hasn't been processed yet
        """
        if self.data is None:
            raise ValueError("File has not been processed yet. Call process() first.")

        # Use cached stats if available
        if self._stats_cache:
            return self._stats_cache

        height_map = self.data["height_map"]
        self._stats_cache = {
            "min": float(height_map.min()),
            "max": float(height_map.max()),
            "mean": float(height_map.mean()),
            "median": float(np.median(height_map)),
            "std": float(height_map.std()),
            "shape": height_map.shape,
            "non_nan": int(np.count_nonzero(~np.isnan(height_map))),
            "nan_count": int(np.count_nonzero(np.isnan(height_map))),
        }
        return self._stats_cache

    def process(
        self, force_offset: Optional[Tuple[float, float]] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Process the TMD file by reading and parsing the data.

        Args:
            force_offset: Optional tuple of (x_offset, y_offset) to override file values

        Returns:
            Dictionary containing metadata and the height map, or None if processing fails
        """
        logger.info("=" * 80)
        logger.info("Processing file: %s", self.file_path)

        # Reset any cached data
        self._stats_cache = {}

        # Validate file existence
        file_path = Path(self.file_path)
        if not file_path.exists():
            logger.error("Error: File not found: %s", self.file_path)
            return None

        # Check if file is empty or too small
        file_size = file_path.stat().st_size
        if file_size < 32:
            logger.error("Error: File is too small to be valid: %d bytes", file_size)
            return None

        # Show file header for debugging
        try:
            self.print_file_header(num_bytes=64)
        except Exception as e:
            logger.error("Error inspecting header: %s", e)
            if self.debug:
                logger.debug(traceback.format_exc())
            return None

        # Process the TMD file
        try:
            metadata, height_map = process_tmd_file(
                self.file_path, force_offset=force_offset, debug=self.debug
            )

            # Build the result dictionary
            self.data = {
                "file_path": self.file_path,
                "version": metadata.get("version", "unknown"),
                "header": metadata.get("header", ""),
                "comment": metadata.get("comment", ""),
                "width": metadata["width"],
                "height": metadata["height"],
                "x_length": metadata["x_length"],
                "y_length": metadata["y_length"],
                "x_offset": metadata["x_offset"],
                "y_offset": metadata["y_offset"],
                "height_map": height_map,
            }

            # Calculate basic statistics
            stats = self.get_stats()

            # Log processing results
            logger.info("Successfully processed TMD file")
            logger.info("Version: %s", self.data["version"])
            logger.info("Comment: %s", self.data["comment"])
            logger.info("Dimensions: %d x %d", self.data["width"], self.data["height"])
            logger.info(
                "X length: %.4f, Y length: %.4f",
                self.data["x_length"],
                self.data["y_length"],
            )
            logger.info(
                "X offset: %.4f, Y offset: %.4f",
                self.data["x_offset"],
                self.data["y_offset"],
            )

            if self.debug:
                logger.debug(
                    "Height statistics: Min: %.4f, Max: %.4f, Mean: %.4f, Std: %.4f",
                    stats["min"],
                    stats["max"],
                    stats["mean"],
                    stats["std"],
                )

                # Check for NaN values
                if stats["nan_count"] > 0:
                    logger.warning(
                        "Warning: Height map contains %d NaN values (%.2f%%)",
                        stats["nan_count"],
                        100.0
                        * stats["nan_count"]
                        / (stats["non_nan"] + stats["nan_count"]),
                    )

            return self.data

        except Exception as e:
            logger.error("Error processing file: %s", str(e))
            if self.debug:
                logger.debug(traceback.format_exc())
            return None

    def get_height_map(self) -> Optional[np.ndarray]:
        """
        Get the processed height map.

        Returns:
            2D numpy array of height values or None if not processed
        """
        return self.data["height_map"] if self.data is not None else None

    def get_metadata(self) -> Dict[str, Any]:
        """
        Get metadata from the processed file.

        Returns:
            Dictionary of metadata values (excluding the height map)

        Raises:
            ValueError: If the file hasn't been processed yet
        """
        if self.data is None:
            raise ValueError("File has not been processed yet. Call process() first.")

        # Return all data except the height map
        return {k: v for k, v in self.data.items() if k != "height_map"}

    def export_metadata(self, output_path: str) -> str:
        """
        Export metadata to a text file.

        Args:
            output_path: Path to save the metadata

        Returns:
            Path to the saved file

        Raises:
            ValueError: If the file hasn't been processed yet
        """
        if self.data is None:
            raise ValueError("File has not been processed yet. Call process() first.")

        with open(output_path, "w") as f:
            f.write(f"TMD File: {self.file_path}\n")
            f.write("=" * 80 + "\n\n")

            metadata = self.get_metadata()
            stats = self.get_stats()

            # Write metadata
            for key, value in metadata.items():
                if key != "file_path":  # Already shown at the top
                    f.write(f"{key}: {value}\n")

            # Write statistics
            f.write("\nHeight Map Statistics\n")
            f.write("-" * 20 + "\n")
            for key, value in stats.items():
                f.write(f"{key}: {value}\n")

        logger.info("Metadata exported to %s", output_path)
        return output_path
